#!/usr/bin/env bash

BOOTSTRAP="${BASH_SOURCE[0]%/*}/bootstrap-prefix.sh"
BOOTURL="http://rsync.prefix.bitzolder.nl/scripts/bootstrap-prefix.sh"
UPLOAD="rsync1.prefix.bitzolder.nl::gentoo-portage-bootstraps"

do_fetch() {
	local FETCH_COMMAND
	# Try to find a download manager, we only deal with wget,
	# curl, FreeBSD's fetch and ftp.
	if [[ x$(type -t wget) == "xfile" ]] ; then
		FETCH_COMMAND="wget -O -"
		[[ $(wget -h) == *"--no-check-certificate"* ]] && \
			FETCH_COMMAND+=" --no-check-certificate"
	elif [[ x$(type -t curl) == "xfile" ]] ; then
		FETCH_COMMAND="curl -f -L"
	else
		echo "could not download ${1##*/}"
		exit 1
	fi

	${FETCH_COMMAND} "${*}" || exit 1
}

do_prepare() {
	local bitw=$1
	local dte=$2
	local bootstrap

	if [[ -n ${RESUME} && -n ${bitw} && -n ${dte} ]] ; then
		bootstrap=${OVERRIDE_EPREFIX:-bootstrap${bitw}-${dte}}/bootstrap-prefix.sh
	elif [[ -n ${DOLOCAL} ]] ; then
		bootstrap=${BOOTSTRAP}
	else
		bootstrap=dobootstrap-do_prepare-$$
		do_fetch ${BOOTURL} > ${bootstrap}
	fi

	local chost
	chost=$(${BASH} ${bootstrap} chost.guess x)
	case ${chost} in
		*86-*)
			if [[ ${bitw} == 64 ]] ; then
				chost=x86_64-${chost#*-}
			else
				bitw=32
				chost=i386-${chost#*-}
			fi
			;;
		x86_64-*)
			if [[ ${bitw} == 32 ]] ; then
				chost=i386-${chost#*-}
			else
				bitw=64
				chost=x86_64-${chost#*-}
			fi
			;;
		powerpc-*)
			if [[ ${bitw} == 64 ]] ; then
				chost=powerpc64-${chost#*-}
			else
				bitw=32
				chost=powerpc-${chost#*-}
			fi
			;;
		aarch64-*|arm64-*)
			bitw=64
			;;
		sparc-*)
			if [[ ${bitw} == 64 ]] ; then
				chost=sparcv9-${chost#*-}
			else
				bitw=32
				chost=sparc-${chost#*-}
			fi
			;;
		sparcv9-*|sparc64-*)
			if [[ ${bitw} == 32 ]] ; then
				chost=sparc-${chost#*-}
			else
				bitw=64
				chost=sparcv9-${chost#*-}
			fi
			;;
		*)
			echo "unhandled CHOST: ${chost}"
			rm -f dobootstrap-do_prepare-$$
			exit 1
			;;
	esac

	[[ -z ${dte} ]] && dte=$(date "+%Y%m%d")
	EPREFIX=${PWD}/bootstrap${bitw}-${dte}
	[[ -n ${OVERRIDE_EPREFIX} ]] && EPREFIX=${OVERRIDE_EPREFIX}

	local bootstrapscript
	bootstrapscript=$(realpath ${BASH_SOURCE[0]} 2>/dev/null)
	if [[ -z ${bootstrapscript} ]] ; then
		local b=${BASH_SOURCE[0]}
		cd "${b%/*}" || return 1
		bootstrapscript=$(pwd -P)/${b##*/}
	fi
	echo "EPREFIX=${EPREFIX}"
	mkdir -p "${EPREFIX}"
	if [[ ${bootstrap} == dobootstrap-do_prepare-$$ ]] ; then
		mv "${bootstrap}" "${EPREFIX}"/bootstrap-prefix.sh
	elif [[ ${bootstrap} != "${EPREFIX}"/bootstrap-prefix.sh ]] ; then
		cp "${bootstrap}" "${EPREFIX}"/bootstrap-prefix.sh
	fi
	cd "${EPREFIX}" || exit 1

	# reminder: MAKE_CONF_ADDITIONAL_USE can be set to add global
	# USE-flags in make.conf prior to stage2 (first emerge usage)
	starttime=${SECONDS}
	env -i \
		HOME=${EPREFIX} \
		SHELL=/bin/sh \
		TERM=${TERM} \
		USER=${USER} \
		CHOST=${chost} \
		EPREFIX=${EPREFIX} \
		${GENTOO_MIRRORS+GENTOO_MIRRORS="${GENTOO_MIRRORS}"} \
		${DOLOCAL+DOLOCAL=1} \
		${RESUME+RESUME=1} \
		${LATEST_TREE_YES+LATEST_TREE_YES=1} \
		${TREE_FROM_SRC+TREE_FROM_SRC=}${TREE_FROM_SRC} \
		${USE_CPU_CORES+USE_CPU_CORES=}${USE_CPU_CORES} \
		${DARWIN_USE_GCC+DARWIN_USE_GCC=}${DARWIN_USE_GCC} \
		${PREFIX_DISABLE_RAP+PREFIX_DISABLE_RAP=}${PREFIX_DISABLE_RAP} \
		${BP_KEEPALIVE_ACTIVE+BP_KEEPALIVE_ACTIVE=}${BP_KEEPALIVE_ACTIVE} \
		${BASH} ${bootstrapscript} bootstrap
	endtime=${SECONDS}

	if [[ -n ${DOPUBLISH} ]] ; then
		echo $((endtime - starttime)) > elapsedtime

		# massage CHOST on Linux systems
		if [[ ${chost} == *-linux-gnu* ]] ; then
			# two choices here: x86_64_ubuntu16-linux-gnu
			#                   x86_64-pc-linux-ubuntu16
			# I choose the latter because it is compatible with most
			# UNIX vendors
			local dist rel
			dist=$(lsb_release -si)
			rel=$(lsb_release -sr)
			if [[ -z ${dist} ]] || [[ -z ${rel} ]] ; then
				source /etc/os-release  # this may fail if the file isn't there
				[[ -z ${dist} ]] && dist=${NAME}
				[[ -z ${dist} ]] && dist=${ID}
				[[ -z ${rel} ]] && rel=${VERSION_ID}

				# Gentoo's versioning isn't really relevant, since it is
				# a rolling distro
				[[ ${dist,,} == "gentoo" ]] && rel=
			fi
			[[ -z ${dist} ]] && dist=linux
			# leave rel unset/empty if we don't know about it
			while [[ ${rel} == *.*.* ]] ; do
				rel=${rel%.*}
			done
			local platform=pc
			# this is the logic used in bootstrap-prefix.sh
			[[ ${PREFIX_DISABLE_RAP} != "yes" ]] && platform=rap
			chost=${chost%%-*}-${platform}-linux-${dist,,}${rel}
		fi

		rsync -q /dev/null ${UPLOAD}/${HOSTNAME}-$$/
		rsync -q /dev/null ${UPLOAD}/${HOSTNAME}-$$/${chost}/
		rsync -rltv \
			--exclude=work/ \
			--exclude=homedir/ \
			--exclude=files \
			--exclude=distdir/ \
			--exclude=image/ \
			{stage,.stage}* \
			bootstrap-prefix.sh \
			startprefix \
			elapsedtime \
			var/cache/distfiles \
			var/tmp/portage \
			var/log/emerge.log \
			etc/portage/make.conf \
			${UPLOAD}/${HOSTNAME}-$$/${chost}/${dte}/
		rsync -q /dev/null \
			${UPLOAD}/${HOSTNAME}-$$/${chost}/${dte}/push-complete/
	fi
}

do_bootstrap() {
	chmod 755 bootstrap-prefix.sh || exit 1
	${BASH} ./bootstrap-prefix.sh ${EPREFIX} noninteractive
}

# re-exec under keepalive wrapper, such that the machine we're running
# on doesn't go to sleep, until we as top-level caller terminate
if [[ -z ${BP_KEEPALIVE_ACTIVE} ]] ; then
	# optional program to keep the machine from sleeping
	# macOS/BSD: caffeinate
	keepalive=$(type -P caffeinate)
	[[ -x ${keepalive} ]] && keepalive+=" -i -m -s" || keepalive=
	if [[ -n ${keepalive} ]] ; then
		export BP_KEEPALIVE_ACTIVE=1
		exec ${keepalive} "${BASH_SOURCE[0]}" "${@}"
	fi
fi

case $1 in
	bootstrap)
		do_bootstrap
		;;
	local)
		export DOLOCAL=1
		do_prepare $2
		;;
	resume)
		export RESUME=1
		do_prepare "$2" ${3:-${BOOTSTRAP_DATE}}
		;;
	*)
		bitw=
		if [[ ${0} == /net/* ]] ; then
			echo "internal host, activating local and DOPUBLISH"
			export DOLOCAL=1
			export DOPUBLISH=1
			export GENTOO_MIRRORS="http://distfileslocal"
		fi
		for arg in "${@:1}" ; do
			case "${arg}" in
				latesttree)   export LATEST_TREE_YES=1      ;;
				norap|no-rap) export PREFIX_DISABLE_RAP=yes ;;
				32|64)        bitw=${arg}                   ;;
			esac
		done
		do_prepare ${bitw}
		;;
esac

